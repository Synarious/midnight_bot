services:
  # The service for your Discord bot
  bot:
    build: .
    restart: always
    command: npm start
    # This waits for the database to be fully ready before starting the bot
    depends_on:
      db:
        condition: service_healthy
    volumes:
      # Mount backup directory to host machine
      - ./data/backup:/usr/src/app/data/backup
    environment:
      # These lines map the variables from your .env file to the container.
      DISCORD_TOKEN: ${DISCORD_TOKEN}
      CLIENT_ID: ${CLIENT_ID}
      GUILD_ID: ${GUILD_ID}
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      BOT_PREFIX: ${BOT_PREFIX}
      BOT_STATUS_MESSAGE: ${BOT_STATUS_MESSAGE}
      HEALTHCHECK_URL: ${HEALTHCHECK_URL}

      # Database connection details for the bot's 'pg' client
      # IMPORTANT: PGHOST is 'db', the name of our database service.
      PGHOST: db
      PGUSER: ${PGUSER}
      PGPASSWORD: ${PGPASSWORD}
      PGDATABASE: ${PGDATABASE}
      PGPORT: ${PGPORT}
      REDIS_HOST: redis
      REDIS_PORT: 6379
    dns:
      - 8.8.8.8
      - 1.1.1.1
    # Healthcheck to ensure runtime is healthy (will run the runtime check script)
    healthcheck:
      test: ["CMD-SHELL", "node scripts/check_runtime.js"]
      interval: 30s
      timeout: 5s
      retries: 3

  # Web dashboard for bot administration
  dashboard:
    build:
      context: ./dashboard
      dockerfile: Dockerfile
    restart: always
    depends_on:
      db:
        condition: service_healthy
    ports:
      # Dashboard accessible ONLY on localhost (127.0.0.1:3002) - not exposed to network
      - "127.0.0.1:3002:3002"
    volumes:
      - ./dashboard:/usr/src/app
      - /usr/src/app/node_modules
    environment:
      # Dashboard port
      PORT: 3002
      # Session secret for cookie signing
      SESSION_SECRET: ${SESSION_SECRET:-change-me-in-production}
      # Admin password
      DASHBOARD_ADMIN_PASSWORD: ${DASHBOARD_ADMIN_PASSWORD}
      # Database connection (same as bot)
      PGHOST: db
      PGUSER: ${PGUSER}
      PGPASSWORD: ${PGPASSWORD}
      PGDATABASE: ${PGDATABASE}
      PGPORT: ${PGPORT}
      REDIS_HOST: redis
      REDIS_PORT: 6379
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3002/api/health || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3

  # The service for the PostgreSQL database
  db:
    image: postgres:15-alpine
    restart: always
    # These variables are required by the postgres image to initialize itself.
    # They are read from your .env file.
    environment:
      POSTGRES_USER: ${PGUSER}
      POSTGRES_PASSWORD: ${PGPASSWORD}
      POSTGRES_DB: ${PGDATABASE}
    volumes:
      # Persists database data across restarts
      - postgres-data:/var/lib/postgresql/data
      # Runs our init.sql script on first startup
      - ./db-init:/docker-entrypoint-initdb.d
    ports:
      # Optional: Expose port 5434 to your host machine for debugging
      - 5431:5429
    # This healthcheck tells Docker how to know when Postgres is truly ready.
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${PGUSER} -d ${PGDATABASE}"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Redis for caching and buffering
  redis:
    image: redis:alpine
    restart: always
    ports:
      - "6379:6379"

# Defines the named volume for persisting database data
volumes:
  postgres-data: